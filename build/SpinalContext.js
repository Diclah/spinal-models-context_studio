"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AbstractElement = require("./AbstractElement");

var _AbstractElement2 = _interopRequireDefault(_AbstractElement);

var _SpinalNode = require("./SpinalNode");

var _SpinalNode2 = _interopRequireDefault(_SpinalNode);

var _Utilities = require("./Utilities");

var _SpinalApplication = require("./SpinalApplication");

var _SpinalApplication2 = _interopRequireDefault(_SpinalApplication);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const spinalCore = require("spinal-core-connectorjs");
const globalType = typeof window === "undefined" ? global : window;


let getViewer = function () {
  return globalType.v;
};

/**
 *
 *
 * @class SpinalContext
 * @extends {SpinalApplication}
 */

class SpinalContext extends _SpinalApplication2.default {
  /**
   *Creates an instance of SpinalContext.
   * @param {string} name
   * @param {string[]} relationsTypesLst
   * @param {Object[]} models
   * @param {Model} [Interactions= new Model()]
   * @param {SpinaNode} [startingNode = new SpinalNode("root",new AbstractElement(_name, "root"))]
   * @param {SpinalGraph} relatedGraph
   * @param {string} [name="SpinalContext"]
   * @memberof SpinalContext
   */
  constructor(_name, relationsTypesLst, models, Interactions = new globalType.Model(), startingNode = new _SpinalNode2.default("root", new _AbstractElement2.default(_name, "root")), relatedGraph, name = "SpinalContext") {
    super(_name, relationsTypesLst, relatedGraph);
    if (FileSystem._sig_server) {
      this.add_attr({
        models: models,
        startingNode: startingNode,
        Interactions: Interactions,
        contextImage: new Lst()
      });
    }
  }
}
exports.default = SpinalContext;

spinalCore.register_models([SpinalContext]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TcGluYWxDb250ZXh0LmpzIl0sIm5hbWVzIjpbInNwaW5hbENvcmUiLCJyZXF1aXJlIiwiZ2xvYmFsVHlwZSIsIndpbmRvdyIsImdsb2JhbCIsImdldFZpZXdlciIsInYiLCJTcGluYWxDb250ZXh0IiwiU3BpbmFsQXBwbGljYXRpb24iLCJjb25zdHJ1Y3RvciIsIl9uYW1lIiwicmVsYXRpb25zVHlwZXNMc3QiLCJtb2RlbHMiLCJJbnRlcmFjdGlvbnMiLCJNb2RlbCIsInN0YXJ0aW5nTm9kZSIsIlNwaW5hbE5vZGUiLCJBYnN0cmFjdEVsZW1lbnQiLCJyZWxhdGVkR3JhcGgiLCJuYW1lIiwiRmlsZVN5c3RlbSIsIl9zaWdfc2VydmVyIiwiYWRkX2F0dHIiLCJjb250ZXh0SW1hZ2UiLCJMc3QiLCJyZWdpc3Rlcl9tb2RlbHMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBWEEsTUFBTUEsYUFBYUMsUUFBUSx5QkFBUixDQUFuQjtBQUNBLE1BQU1DLGFBQWEsT0FBT0MsTUFBUCxLQUFrQixXQUFsQixHQUFnQ0MsTUFBaEMsR0FBeUNELE1BQTVEOzs7QUFJQSxJQUFJRSxZQUFZLFlBQVc7QUFDekIsU0FBT0gsV0FBV0ksQ0FBbEI7QUFDRCxDQUZEOztBQVFBOzs7Ozs7O0FBT0EsTUFBTUMsYUFBTixTQUE0QkMsMkJBQTVCLENBQThDO0FBQzVDOzs7Ozs7Ozs7OztBQVdBQyxjQUNFQyxLQURGLEVBRUVDLGlCQUZGLEVBR0VDLE1BSEYsRUFJRUMsZUFBZSxJQUFJWCxXQUFXWSxLQUFmLEVBSmpCLEVBS0VDLGVBQWUsSUFBSUMsb0JBQUosQ0FBZSxNQUFmLEVBQXVCLElBQUlDLHlCQUFKLENBQW9CUCxLQUFwQixFQUEyQixNQUEzQixDQUF2QixDQUxqQixFQU1FUSxZQU5GLEVBT0VDLE9BQU8sZUFQVCxFQVFFO0FBQ0EsVUFBTVQsS0FBTixFQUFhQyxpQkFBYixFQUFnQ08sWUFBaEM7QUFDQSxRQUFJRSxXQUFXQyxXQUFmLEVBQTRCO0FBQzFCLFdBQUtDLFFBQUwsQ0FBYztBQUNaVixnQkFBUUEsTUFESTtBQUVaRyxzQkFBY0EsWUFGRjtBQUdaRixzQkFBY0EsWUFIRjtBQUlaVSxzQkFBYyxJQUFJQyxHQUFKO0FBSkYsT0FBZDtBQU1EO0FBQ0Y7QUE5QjJDO2tCQWdDL0JqQixhOztBQUNmUCxXQUFXeUIsZUFBWCxDQUEyQixDQUFDbEIsYUFBRCxDQUEzQiIsImZpbGUiOiJTcGluYWxDb250ZXh0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgc3BpbmFsQ29yZSA9IHJlcXVpcmUoXCJzcGluYWwtY29yZS1jb25uZWN0b3Jqc1wiKTtcbmNvbnN0IGdsb2JhbFR5cGUgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuaW1wb3J0IEFic3RyYWN0RWxlbWVudCBmcm9tIFwiLi9BYnN0cmFjdEVsZW1lbnRcIjtcbmltcG9ydCBTcGluYWxOb2RlIGZyb20gXCIuL1NwaW5hbE5vZGVcIjtcblxubGV0IGdldFZpZXdlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZ2xvYmFsVHlwZS52O1xufTtcblxuaW1wb3J0IHsgVXRpbGl0aWVzIH0gZnJvbSBcIi4vVXRpbGl0aWVzXCI7XG5cbmltcG9ydCBTcGluYWxBcHBsaWNhdGlvbiBmcm9tIFwiLi9TcGluYWxBcHBsaWNhdGlvblwiO1xuXG4vKipcbiAqXG4gKlxuICogQGNsYXNzIFNwaW5hbENvbnRleHRcbiAqIEBleHRlbmRzIHtTcGluYWxBcHBsaWNhdGlvbn1cbiAqL1xuXG5jbGFzcyBTcGluYWxDb250ZXh0IGV4dGVuZHMgU3BpbmFsQXBwbGljYXRpb24ge1xuICAvKipcbiAgICpDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFNwaW5hbENvbnRleHQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHJlbGF0aW9uc1R5cGVzTHN0XG4gICAqIEBwYXJhbSB7T2JqZWN0W119IG1vZGVsc1xuICAgKiBAcGFyYW0ge01vZGVsfSBbSW50ZXJhY3Rpb25zPSBuZXcgTW9kZWwoKV1cbiAgICogQHBhcmFtIHtTcGluYU5vZGV9IFtzdGFydGluZ05vZGUgPSBuZXcgU3BpbmFsTm9kZShcInJvb3RcIixuZXcgQWJzdHJhY3RFbGVtZW50KF9uYW1lLCBcInJvb3RcIikpXVxuICAgKiBAcGFyYW0ge1NwaW5hbEdyYXBofSByZWxhdGVkR3JhcGhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lPVwiU3BpbmFsQ29udGV4dFwiXVxuICAgKiBAbWVtYmVyb2YgU3BpbmFsQ29udGV4dFxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgX25hbWUsXG4gICAgcmVsYXRpb25zVHlwZXNMc3QsXG4gICAgbW9kZWxzLFxuICAgIEludGVyYWN0aW9ucyA9IG5ldyBnbG9iYWxUeXBlLk1vZGVsKCksXG4gICAgc3RhcnRpbmdOb2RlID0gbmV3IFNwaW5hbE5vZGUoXCJyb290XCIsIG5ldyBBYnN0cmFjdEVsZW1lbnQoX25hbWUsIFwicm9vdFwiKSksXG4gICAgcmVsYXRlZEdyYXBoLFxuICAgIG5hbWUgPSBcIlNwaW5hbENvbnRleHRcIlxuICApIHtcbiAgICBzdXBlcihfbmFtZSwgcmVsYXRpb25zVHlwZXNMc3QsIHJlbGF0ZWRHcmFwaCk7XG4gICAgaWYgKEZpbGVTeXN0ZW0uX3NpZ19zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuYWRkX2F0dHIoe1xuICAgICAgICBtb2RlbHM6IG1vZGVscyxcbiAgICAgICAgc3RhcnRpbmdOb2RlOiBzdGFydGluZ05vZGUsXG4gICAgICAgIEludGVyYWN0aW9uczogSW50ZXJhY3Rpb25zLFxuICAgICAgICBjb250ZXh0SW1hZ2U6IG5ldyBMc3QoKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZGVmYXVsdCBTcGluYWxDb250ZXh0O1xuc3BpbmFsQ29yZS5yZWdpc3Rlcl9tb2RlbHMoW1NwaW5hbENvbnRleHRdKTtcbiJdfQ==